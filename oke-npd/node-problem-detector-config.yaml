apiVersion: v1
data:
  kernel-monitor.json: |
    {
        "plugin": "kmsg",
        "logPath": "/dev/kmsg",
        "lookback": "5m",
        "bufferSize": 10,
        "source": "kernel-monitor",
        "conditions": [
            {
                "type": "KernelDeadlock",
                "reason": "KernelHasNoDeadlock",
                "message": "kernel has no deadlock"
            },
            {
                "type": "ReadonlyFilesystem",
                "reason": "FilesystemIsNotReadOnly",
                "message": "Filesystem is not read-only"
            }
        ],
        "rules": [
            {
                "type": "temporary",
                "reason": "OOMKilling",
                "pattern": "Kill process \\d+ (.+) score \\d+ or sacrifice child\\nKilled process \\d+ (.+) total-vm:\\d+kB, anon-rss:\\d+kB, file-rss:\\d+kB.*"
            },
            {
                "type": "temporary",
                "reason": "TaskHung",
                "pattern": "task \\S+:\\w+ blocked for more than \\w+ seconds\\."
            },
            {
                "type": "temporary",
                "reason": "UnregisterNetDevice",
                "pattern": "unregister_netdevice: waiting for \\w+ to become free. Usage count = \\d+"
            },
            {
                "type": "temporary",
                "reason": "KernelOops",
                "pattern": "BUG: unable to handle kernel NULL pointer dereference at .*"
            },
            {
                "type": "temporary",
                "reason": "KernelOops",
                "pattern": "divide error: 0000 \\[#\\d+\\] SMP"
            },
            {
    			"type": "temporary",
    			"reason": "MemoryReadError",
    			"pattern": "CE memory read error .*"
            },
            {
                "type": "permanent",
                "condition": "KernelDeadlock",
                "reason": "DockerHung",
                "pattern": "task docker:\\w+ blocked for more than \\w+ seconds\\."
            },
            {
                "type": "permanent",
                "condition": "ReadonlyFilesystem",
                "reason": "FilesystemIsReadOnly",
                "pattern": "Remounting filesystem read-only"
            }
        ]
    }
  readonly-monitor.json: |
    {
        "plugin": "kmsg",
        "logPath": "/dev/kmsg",
        "lookback": "5m",
        "bufferSize": 10,
        "source": "readonly-monitor",
        "metricsReporting": true,
        "conditions": [
            {
                "type": "ReadonlyFilesystem",
                "reason": "FilesystemIsNotReadOnly",
                "message": "Filesystem is not read-only"
            }
        ],
        "rules": [
            {
                "type": "permanent",
                "condition": "ReadonlyFilesystem",
                "reason": "FilesystemIsReadOnly",
                "pattern": "Remounting filesystem read-only"
            }
        ]
    }
  docker-monitor.json: |
    {
        "plugin": "journald",
        "pluginConfig": {
            "source": "dockerd"
        },
        "logPath": "/var/log/journal",
        "lookback": "5m",
        "bufferSize": 10,
        "source": "docker-monitor",
        "conditions": [],
        "rules": [
            {
                "type": "temporary",
                "reason": "CorruptDockerImage",
                "pattern": "Error trying v2 registry: failed to register layer: rename /var/lib/docker/image/(.+) /var/lib/docker/image/(.+): directory not empty.*"
            }
        ]
    }
  oke-gpu-healthcheck.json: |
    {
    "plugin": "custom",
    "pluginConfig": {
        "invoke_interval": "300s",
        "timeout": "30s",
        "max_output_length": 80,
        "concurrency": 3,
        "enable_message_change_based_condition_update": false
    },
    "source": "oke-gpu-healthcheck",
    "metricsReporting": true,
    "conditions": [
        {
        "type": "OKEHealthCheck",
        "reason": "GpuRdmaHasNoIssues",
        "message": "No issues detected with GPUs or RDMA interfaces"
        }
    ],
    "rules": [
        {
        "type": "temporary",
        "reason": "GpuRdmaHasIssues",
        "path": "./config/plugin/oke-healthchecks.sh",
        "timeout": "30s"
        },
        {
        "type": "permanent",
        "condition": "OKEHealthCheck",
        "reason": "GpuRdmaHasIssues",
        "path": "./config/plugin/oke-healthchecks.sh",
        "timeout": "30s"
        }
    ]
    }
  check_nvidia_gpu_setup.py: |
    #!/usr/bin/env python3

    import subprocess
    import re
    import argparse
    from datetime import datetime
    from shared_logging import logger
    from rdma_link_flapping import LinkFlappingTest
    from xid_checker import XidChecker
    import platform
    import os
    import requests

    def get_metadata():
        """ Make a request to metadata endpoint """
        headers = { 'Authorization' : 'Bearer Oracle' }
        metadata_url = "http://169.254.169.254/opc/"
        metadata_ver = "2"
        request_url = metadata_url + "v" + metadata_ver + "/instance/"
        return requests.get(request_url, headers=headers).json()

    def is_user_root():
        # Check if the user is root
        if os.geteuid() != 0:
            logger.debug("User is root")
            return False
        return True

    def get_oca_version():
        # Run the shell command
        os_name = platform.system()


        if os_name == 'Linux':
            try:
                distro = platform.linux_distribution()[0]
            except:
                import distro
                distro = distro.name()

            if 'Ubuntu' in distro:
                if not is_user_root():
                    result = subprocess.run(['sudo', 'snap', 'info', 'oracle-cloud-agent'], stdout=subprocess.PIPE)
                else:
                    result = subprocess.run(['snap', 'info', 'oracle-cloud-agent'], stdout=subprocess.PIPE)

                # Decode the output from bytes to string
                output = result.stdout.decode('utf-8')

                # Define the regular expression pattern for the version
                pattern = r'installed:\s+(\d+\.\d+\.\d+)'
                match = re.search(pattern, output)
                if match:
                    version = match.group(1)

            elif 'Oracle' in distro:
                result = subprocess.run(['rpm', '-qa'], stdout=subprocess.PIPE)

                # Decode the output from bytes to string
                output = result.stdout.decode('utf-8')

                # Define the regular expression pattern for the version
                pattern = r'oracle-cloud-agent-(\d+\.\d+\.\d+)'
                match = re.search(pattern, output)
                if match:
                    version = match.group(1)


            if version < "1.39.0":
                logger.error(f"Oracle Cloud Agent: {version} needs to be updated to 1.39.0 or higher")
            else:
                logger.info(f"Oracle Cloud Agent: {version}")

            # Return the version
            return version

    def check_rttcc_status():
        link_status = []
        metadata=get_metadata()
        shape=metadata['shape']
        if shape == "BM.GPU.H100.8":
            devices = ["mlx5_0", "mlx5_1", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        elif shape == "BM.GPU.B4.8" or shape == "BM.GPU.A100-v2.8":
            devices = ["mlx5_1", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        elif shape == "BM.GPU4.8":
            devices = ["mlx5_0", "mlx5_1", "mlx5_2", "mlx5_3", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        status = "disabled"
        status_dict = {"devices": {}}
        for device in devices:
            if not is_user_root():
                command = ['sudo', 'mlxreg', '-d', device, '-y', '--get', '--reg_name=PPCC', '--indexes=local_port=1,pnat=0,lp_msb=0,algo_slot=0,algo_param_index=0']
            else:
                command = ['mlxreg', '-d', device, '-y', '--set', 'cmd_type=3', '--reg_name=PPCC', '--indexes=local_port=1,pnat=0,lp_msb=0,algo_slot=0,algo_param_index=0']
            result = subprocess.run(command, stdout=subprocess.PIPE,stderr=subprocess.PIPE)
            output = result.stdout.decode('utf-8')
            filtered_output = [line for line in output.split('\n') if line.startswith('value')]
            for line in filtered_output:
                logger.debug(line)
                if "0x00000001" in line:
                    status_dict["devices"][device] = "enabled"

        for device in status_dict["devices"]:
            if status_dict["devices"][device] == "enabled":
                logger.warning(f"RTTCC enabled on {device}")
                status = "enabled"
                link_status.append(f"RTTCC enabled on: {device}")
            else:
                logger.info(f"RTTCC status for {device}: disabled")
        if status == "disabled":
            logger.info(f"RTTCC disabled check: Passed")
        else:
            logger.error(f"RTTCC disabled check: Failed")

        return link_status

    def check_ecc_errors():
        ecc_issues = []
        try:
            # Run the nvidia-smi -q command
            result = subprocess.run(['nvidia-smi', '-q'], stdout=subprocess.PIPE)
        except FileNotFoundError:
            logger.warning("Skipping SRAM/DRAM ECC Test: nvidia-smi command not found")
            return []

        # Decode the output from bytes to string
        output = result.stdout.decode('utf-8')

        # Find the lines containing "SRAM Correctable" and "DRAM Correctable"
        sram_matches = re.findall(r'SRAM Uncorrectable\s+:\s+(\d+)', output)
        if len(sram_matches)==0:
            sram_matches = re.findall(r'SRAM Uncorrectable Parity\s+:\s+(\d+)', output)
        dram_matches = re.findall(r'DRAM Uncorrectable\s+:\s+(\d+)', output)
        gpu_matches = re.findall(r'\nGPU\s+(.*)\n', output)
        vol_sram_line = sram_matches[0::2]
        vol_dram_line = dram_matches[0::2]
        agg_sram_line = sram_matches[1::2]
        agg_dram_line = dram_matches[1::2]

        for i, gpu in enumerate(gpu_matches):
            logger.debug(f"GPU: {gpu}")
            if vol_sram_line[i] != "0":
                logger.debug(f"Volatile SRAM Uncorrectable: {vol_sram_line[i]}")
                ecc_issues.append(f"{gpu_matches[i]} - Volatile SRAM Uncorrectable: {vol_sram_line[i]}")
            if vol_dram_line[i] != "0":
                logger.debug(f"Volatile DRAM Uncorrectable: {vol_dram_line[i]}")
                ecc_issues.append(f"{gpu_matches[i]} - Volatile DRAM Uncorrectable: {vol_dram_line[i]}")
            if agg_sram_line[i] != "0":
                logger.debug(f"Aggregate SRAM Uncorrectable: {agg_sram_line[i]}")
                ecc_issues.append(f"{gpu_matches[i]} - Aggregate SRAM Uncorrectable: {agg_sram_line[i]}")
            if agg_dram_line[i] != "0":
                logger.debug(f"Aggregate DRAM Uncorrectable: {agg_dram_line[i]}")
                ecc_issues.append(f"{gpu_matches[i]} - Aggregate DRAM Uncorrectable: {agg_dram_line[i]}")


        # Check if there are ecc_issues
        if len(ecc_issues) == 0:
            logger.info("GPU ECC Test: Passed")
        else:
            logger.warning("GPU ECC Test: Failed")

        return ecc_issues

    def check_row_remap_errors():
        remap_issues = []
        try:
            # Run the nvidia-smi -q command
            result = subprocess.run(['nvidia-smi', '--query-remapped-rows=remapped_rows.pending,remapped_rows.failure,remapped_rows.uncorrectable', '--format=csv,noheader'], stdout=subprocess.PIPE)

            if result.returncode != 0:
                logger.debug(f"Check row remap command exited with error code: {result.returncode}")

        except FileNotFoundError:
            logger.warning("Skipping Row Remap Test: nvidia-smi command not found")
            return []

        # Decode the output from bytes to string
        output = result.stdout.decode('utf-8')
        logger.debug("Output: {}".format(output))
        for i, line in enumerate(output.split('\n')):
            if line == "":
                continue
            tmp_data = line.split(",")
            tmp_data = [x.strip() for x in tmp_data]
            if tmp_data[0] != "0" and tmp_data[0] != "No":
                logger.debug(f"GPU: {i} - Row Remap Pending: {tmp_data[0]}")
                remap_issues.append(f"GPU: {i} Row Remap Pending: {tmp_data[0]}")
            if tmp_data[1] != "0" and tmp_data[0] != "No":
                logger.debug(f"GPU: {i} - Row Remap Failure: {tmp_data[1]}")
                #remap_issues.append(f"GPU: {i} Row Remap Failure: {tmp_data[1]}")
            if tmp_data[2] != "0" and tmp_data[0] != "No":
                logger.debug(f"GPU: {i} - Row Remap Uncorrectable: {tmp_data[2]}")
                if int(tmp_data[2]) > 512:
                    remap_issues.append(f"GPU: {i} - Row Remap Uncorrectable >512: {tmp_data[2]}")
                else:
                    remap_issues.append(f"GPU: {i} - Row Remap Uncorrectable <512: {tmp_data[2]}")# Check if there are ecc_issues

        if len(remap_issues) == 0:
            logger.info("GPU Remap Test: Passed")
        else:
            logger.warning("GPU Remap Test: Failed")

        return remap_issues

    def check_rdma_link_status():
        status = True
        metadata=get_metadata()
        shape=metadata['shape']
        if shape == "BM.GPU.H100.8":
            devices = ["mlx5_0", "mlx5_1", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        elif shape == "BM.GPU.B4.8" or shape == "BM.GPU.A100-v2.8":
            devices = ["mlx5_1", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        elif shape == "BM.GPU4.8":
            devices = ["mlx5_0", "mlx5_1", "mlx5_2", "mlx5_3", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        link_issues = []
        for device in devices:
            # Run the mlxlink command
            if not is_user_root():
                command = ['sudo', 'mlxlink', '-d', device, '-m', '-c', '-e']
            else:
                command = ['mlxlink', '-d', device, '-m', '-c', '-e']
            result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            # Decode the output from bytes to string
            output = result.stdout.decode('utf-8')
            stderr = result.stderr.decode('utf-8')

            if stderr and stderr.find("-E-") != -1:
                stderr = stderr.split("\n")
                stderr_line = ", ".join(stderr)
                logger.debug(f"{device}: {stderr_line}")
                link_issues.append(f"{device}: {stderr[0]}")
                status = "False"
                continue

            # Find the line containing "Recommendation"
            color_pattern = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
            link_state = re.search(r'\nState.*', output).group().split(":")[1].strip()
            recommendation = re.search(r'Recommendation.*', output).group().split(":")[1].strip()
            vendor_serial_num = re.search(r'Vendor Serial Number.*', output).group().split(":")[1].strip()
            nic_fw_version = re.search(r'Firmware Version.*', output).group().split(":")[1].strip()
            cable_fw_version = re.search(r'FW Version.*', output).group().split(":")[1].strip()
            physical_BER = re.search(r'Raw Physical BER.*', output).group().split(":")[1].strip()
            # Remove hidden characters from the output
            link_state = re.sub(color_pattern, '', link_state)
            nic_fw_version = re.sub(color_pattern, '', nic_fw_version)
            recommendation = re.sub(color_pattern, '', recommendation)

            logger.debug(f"{device}: {vendor_serial_num} - {cable_fw_version} - {nic_fw_version} - {link_state} - {recommendation}")

            # Extract the part after the ":" and print it along with the device name
            if link_state != "Active":
                logger.debug(f"{device}: {link_state}")
                link_issues.append(f"{device} - {vendor_serial_num} - {cable_fw_version} - {nic_fw_version}: {link_state}")
                status = False
            if not "No issue was observed" in recommendation:
                logger.debug(f"{device}: {recommendation}")
                if "Bad signal integrity" in recommendation and float(physical_BER) < 1e-07:
                    logger.debug(f"Recommandation is {recommendation} but the Physical error are low enough that it can be ignored")
                else : 
                    logger.debug(f"Recommandation is {recommendation} and the Physical error count is too high to be ignored: {physical_BER}")
                    link_issues.append(f"{device} - {vendor_serial_num} - {cable_fw_version} - {nic_fw_version}: {recommendation}")
                    status = False
            else:
                logger.debug(f"{device}: {recommendation}")

        if status:
            logger.info(f"RDMA Link Status Check: Passed")
        else:
            logger.warning(f"RDMA Link Status Check: Failed")
        return link_issues

    def get_host_serial():
        # Run the shell command
        if not is_user_root():
            result = subprocess.run(['sudo', 'dmidecode', '-s', 'system-serial-number'], stdout=subprocess.PIPE)
        else:
            result = subprocess.run(['dmidecode', '-s', 'system-serial-number'], stdout=subprocess.PIPE)

        # Decode the output from bytes to string
        output = result.stdout.decode('utf-8')

        # Return the serial number
        return output.strip()

    def check_bus():
        # Check to see if any devices have fallen of the bus
        command = ['lspci', '-v']
        result = subprocess.run(command, stdout=subprocess.PIPE)
        output = result.stdout.decode('utf-8')
        lines = output.split('\n')
        bus_issues = []
        for line in lines:
            if line.find('(rev ff)') != -1:
                bus_issues.append(line)
        if len(bus_issues) > 0:
            logger.error(f"Devices have fallen off the bus")
        else:
            logger.info("No devices have fallen off the bus")
        if len(bus_issues) == 0:
            logger.info("Bus Check Test: Passed")
            return(bus_issues)
        else:
            logger.warning("Bus Check Test: Failed")
            return(bus_issues)

    def check_gpu_count():

        lspci_expected_results = [  '0f:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                    '2d:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                    '44:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                    '5b:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                    '89:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                    'a8:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                    'c0:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
                                    'd8:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)'
                                ]

        # Check the number of GPUs
        try:
            result = subprocess.run(['nvidia-smi', '--list-gpus'], stdout=subprocess.PIPE)
            output = result.stdout.decode('utf-8')
            lines = output.split('\n')
            tmp_results = []
            # remove empty lines
            lines = [line for line in lines if line]
            if len(lines) == 8:
                logger.info("GPU Count Test: Passed")
            else:
                logger.warning("GPU Count Test: Failed")
                tmp_results.append(f"Expected 8 GPUs, found {len(lines)} using nvidia-smi command")
            return tmp_results

        except FileNotFoundError:
            try:
                # Check if lspci is available
                result = subprocess.run(['lspci', '-v'], stdout=subprocess.PIPE)
                output = result.stdout.decode('utf-8')

                # Check if the expected results are in the output
                lines = output.split('\n')
                tmp_results = []
                missing_gpus = []
                for line in lines:
                    if line.find("NVIDIA") != -1 and line.find("2330") != -1:
                        tmp_results.append(line)
                if not len(tmp_results) == 8:
                    logger.debug(f"Expected 8 GPUs, found {len(tmp_results)} in lspci output")
                    for line in lspci_expected_results:
                        if line not in tmp_results:
                            missing_gpus.append(f"Missing GPU: {line}")
                if len(tmp_results) == 8:
                    logger.info("GPU Count Test: Passed")
                else:
                    logger.warning("GPU Count Test: Failed")
                return missing_gpus
            except FileNotFoundError:
                logger.warning("Skipping GPU count test: nvidia-smi and lspci commands not found")
                return None

    def slurm_reason(message):
        global slurm_drain_reason
        global slurm_error_count
        slurm_drain_reason+=(message+"\n")
        slurm_error_count+=1

    if __name__ == '__main__':
        parser = argparse.ArgumentParser(description='Check Host setup')
        parser.add_argument("-l", "--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"], default="INFO", help="Set the logging level default: INFO")
        parser.add_argument('--bw-test', dest='bw_test', action='store_true', default=False, help='Run GPU bandwidth test (default: False)')
        parser.add_argument('--bw-test-exe', dest='bw_test_exe', help='Location to cuda-sampels bandwidthTest')
        parser.add_argument('--lf-interval', dest='lf_interval', default=6, type=int, help='Link flapping interval with no flapping or link down events (default: 6 (hours))')
        parser.add_argument('-a','--all', dest='run_all', action='store_true', default=False, help='Run all checks (default: False)')
        parser.add_argument('-slurm','--slurm', dest='slurm', action='store_true', default=False, help='Add a Slurm message')
        args = parser.parse_args()

        logger.setLevel(args.log_level)

        datetime_str = datetime.now().strftime('%Y-%m-%d-%H%M%S')
        logger.info(f"Started GPU host setup check at: {datetime_str}")
        try:
            oca_version = get_oca_version()
        except Exception as e:
            logger.warning(f"Failed to get Oracle Cloud Agent version with error: {e}")
            oca_version = "Unknown"
        try:
            rttcc_issues = check_rttcc_status()
        except Exception as e:
            logger.warning(f"Failed to check RTTCC status with error: {e}")
            rttcc_issues = []

        # Check for ECC errors
        try:
            ecc_issues = check_ecc_errors()
        except Exception as e:
            logger.warning(f"Failed to check ECC errors with error: {e}")
            ecc_issues = []

        # Check for row remap errors
        try:
            remap_results = check_row_remap_errors()
        except Exception as e:
            logger.warning(f"Failed to check row remap errors with error: {e}")
            remap_results = []

        # Check RDMA link status
        try:
            rdma_link_issues = check_rdma_link_status()
        except Exception as e:
            logger.warning(f"Failed to check RDMA link status with error: {e}")
            rdma_link_issues = []

        # Check for RDMA link flapping
        try:
            lft = LinkFlappingTest(time_interval=args.lf_interval)
            lft.get_rdma_link_failures()
            lft_issues = lft.process_rdma_link_flapping()
        except Exception as e:
            logger.warning(f"Failed to check RDMA link flapping with error: {e}")
            lft_issues = {"failures": [], "link_down": []}

        # Check for GPU Xid errors
        try:
            xc = XidChecker()
            xid_results = xc.check_gpu_xid()
        except Exception as e:
            logger.warning(f"Failed to check GPU Xid errors with error: {e}")
            xid_results = {"status": "None", "results": {}}

        # Check GPU bandwidth
        bwt_results = None
        try:
            if args.bw_test == True or args.run_all == True:
                if args.bw_test_exe:
                    bwt = BandwidthTest(bw_test_exe=args.bw_test_exe)
                else:
                    bwt = BandwidthTest()
                bwt.measure_gpu_bw()
                bwt_results = bwt.validate_results()
        except Exception as e:
            logger.warning(f"Failed to check GPU bandwidth with error: {e}")
            bwt_results = None

        # Check the bus
        try:
            bus_results = check_bus()
        except Exception as e:
            logger.warning(f"Failed to check the bus with error: {e}")
            bus_results = None

        # Check the number of GPUs
        try:
            gpu_results = check_gpu_count()
        except Exception as e:
            logger.warning(f"Failed to check the number of GPUs with error: {e}")
            gpu_results = None

        # Summarize the results
        try:
            host_serial = get_host_serial()
        except Exception as e:
            logger.warning(f"Failed to get host serial number with error: {e}")
            host_serial = "Unknown"

        slurm_drain_reason = ""
        slurm_error_count = 0

        logger.info(f"--------- Summary of Host setup check for {host_serial} ---------")
        if oca_version < "1.39.0":
            logger.error(f"Oracle Cloud Agent: {oca_version} needs to be updated to 1.39.0 or higher")
            slurm_reason("OCA version Error")
        if len(rttcc_issues) > 0:
            logger.error(f"RTTCC issues: {rttcc_issues}")
            slurm_reason("RTTCC Error")
        if len(ecc_issues) > 0:
            ecc_error=False
            for issue in ecc_issues:
                if "Skipped" in issue:
                    logger.warning(f"{host_serial} - {issue}")
                else:
                    if "Aggregate" in issue:
                        logger.warning(f"{host_serial} - ECC issues: {issue}")
                    else:
                        logger.error(f"{host_serial} - ECC issues: {issue}")
                        ecc_error=True
            if ecc_error:
                slurm_reason("ECC Error")
        if len(remap_results) > 0:
            remap_error=False
            for issue in remap_results:
                if "<512" in issue:
                    logger.warning(f"{host_serial} - {issue}")
                else:
                    logger.error(f"{host_serial} - {issue}")
                    remap_error=True
            if remap_error:
                slurm_reason("Remap Error")
        if xid_results["status"] == "Failed":
            for xid in xid_results["results"]:
                for pci in xid_results["results"][xid]["results"]:
                    logger.error(f"{host_serial} - GPU Xid {xid} device: {pci}, {xid_results['results'][xid]['description']}")
                    slurm_reason("XID Error")
        if len(rdma_link_issues) > 0:
            for issue in rdma_link_issues:
                logger.error(f"{host_serial} - RDMA link issues: {issue}")
                slurm_reason("RDMA Link Error")
        if len(lft_issues["failures"]) > 0 or len(lft_issues["link_down"]) > 0:
            if len(lft_issues["failures"]) > 0:
                for issue in lft_issues["failures"]:
                    logger.error(f"{host_serial} - RDMA link flapping issues: {issue}")
                    slurm_reason("RDMA Link Flapping Error")
            if len(lft_issues["link_down"]) > 0:
                for issue in lft_issues["link_down"]:
                    logger.error(f"{host_serial} - RDMA link down issues: {issue}")
                    slurm_reason("RDMA Link Down Error")
        if bwt_results != None:
            if bwt_results["status"] == "Failed":
                for issue in bwt_results["issues"]:
                    logger.error(f"{host_serial} - GPU bandwidth issues: {issue}")
                    slurm_reason("GPU Bwt Error")
        if bus_results:
            logger.error(f"{host_serial} - Bus issues: {bus_results}")
            slurm_reason("GPU Bus Error")
        if gpu_results:
            logger.error(f"{host_serial} - Missing GPU(s): {gpu_results}")
            slurm_reason("Missing GPU Error")

        datetime_str = datetime.now().strftime('%Y-%m-%d-%H%M%S')
        logger.info(f"Finished GPU host setup check at: {datetime_str}")

        if slurm_error_count > 0 and args.slurm:
            print("Healthcheck:: "+slurm_drain_reason[:-1])    
  check_amd_gpu_setup.py: |
    #!/usr/bin/env python3

    import subprocess
    import re
    import argparse
    from datetime import datetime
    from shared_logging import logger
    #from gpu_bw_test import BandwidthTest
    from rdma_link_flapping import LinkFlappingTest
    #from xid_checker import XidChecker
    import platform
    import os
    import requests

    def get_metadata():
        """ Make a request to metadata endpoint """
        headers = { 'Authorization' : 'Bearer Oracle' }
        metadata_url = "http://169.254.169.254/opc/"
        metadata_ver = "2"
        request_url = metadata_url + "v" + metadata_ver + "/instance/"
        return requests.get(request_url, headers=headers).json()

    def is_user_root():
        # Check if the user is root
        if os.geteuid() != 0:
            logger.debug("User is root")
            return False
        return True

    def get_oca_version():
        # Run the shell command
        os_name = platform.system()


        if os_name == 'Linux':
            try:
                distro = platform.linux_distribution()[0]
            except:
                import distro
                distro = distro.name()

            if 'Ubuntu' in distro:
                if not is_user_root():
                    result = subprocess.run(['sudo', 'snap', 'info', 'oracle-cloud-agent'], stdout=subprocess.PIPE)
                else:
                    result = subprocess.run(['snap', 'info', 'oracle-cloud-agent'], stdout=subprocess.PIPE)

                # Decode the output from bytes to string
                output = result.stdout.decode('utf-8')

                # Define the regular expression pattern for the version
                pattern = r'installed:\s+(\d+\.\d+\.\d+)'
                match = re.search(pattern, output)
                if match:
                    version = match.group(1)

            elif 'Oracle' in distro:
                result = subprocess.run(['rpm', '-qa'], stdout=subprocess.PIPE)

                # Decode the output from bytes to string
                output = result.stdout.decode('utf-8')

                # Define the regular expression pattern for the version
                pattern = r'oracle-cloud-agent-(\d+\.\d+\.\d+)'
                match = re.search(pattern, output)
                if match:
                    version = match.group(1)


            if version < "1.39.0":
                logger.error(f"Oracle Cloud Agent: {version} needs to be updated to 1.38.0 or higher")
            else:
                logger.info(f"Oracle Cloud Agent: {version}")

            # Return the version
            return version

    def check_rttcc_status():
        link_status = []
        metadata=get_metadata()
        shape=metadata['shape']
        if shape == "BM.GPU.H100.8":
            devices = ["mlx5_0", "mlx5_1", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        elif shape == "BM.GPU.B4.8" or shape == "BM.GPU.A100-v2.8":
            devices = ["mlx5_1", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        elif shape == "BM.GPU4.8":
            devices = ["mlx5_0", "mlx5_1", "mlx5_2", "mlx5_3", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        elif shape == "BM.GPU.MI300X.8":
            devices = ["mlx5_0", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_7", "mlx5_8", "mlx5_9"]    
        status = "disabled"
        status_dict = {"devices": {}}
        for device in devices:
            if not is_user_root():
                command = ['sudo', 'mlxreg', '-d', device, '-y', '--get', '--reg_name=PPCC', '--indexes=local_port=1,pnat=0,lp_msb=0,algo_slot=0,algo_param_index=0']
            else:
                command = ['mlxreg', '-d', device, '-y', '--set', 'cmd_type=3', '--reg_name=PPCC', '--indexes=local_port=1,pnat=0,lp_msb=0,algo_slot=0,algo_param_index=0']
            result = subprocess.run(command, stdout=subprocess.PIPE,stderr=subprocess.PIPE)
            output = result.stdout.decode('utf-8')
            filtered_output = [line for line in output.split('\n') if line.startswith('value')]
            for line in filtered_output:
                logger.debug(line)
                if "0x00000001" in line:
                    status_dict["devices"][device] = "enabled"

        for device in status_dict["devices"]:
            if status_dict["devices"][device] == "enabled":
                logger.warning(f"RTTCC enabled on {device}")
                status = "enabled"
                link_status.append(f"RTTCC enabled on: {device}")
            else:
                logger.info(f"RTTCC status for {device}: disabled")
        if status == "disabled":
            logger.info(f"RTTCC disabled check: Passed")
        else:
            logger.error(f"RTTCC disabled check: Failed")

        return link_status

    # def check_ecc_errors():
    #     ecc_issues = []
    #     try:
    #         # Run the nvidia-smi -q command
    #         result = subprocess.run(['nvidia-smi', '-q'], stdout=subprocess.PIPE)
    #     except FileNotFoundError:
    #         logger.warning("Skipping SRAM/DRAM ECC Test: nvidia-smi command not found")
    #         return []

    #     # Decode the output from bytes to string
    #     output = result.stdout.decode('utf-8')

    #     # Find the lines containing "SRAM Correctable" and "DRAM Correctable"
    #     sram_matches = re.findall(r'SRAM Uncorrectable\s+:\s+(\d+)', output)
    #     if len(sram_matches)==0:
    #         sram_matches = re.findall(r'SRAM Uncorrectable Parity\s+:\s+(\d+)', output)
    #     dram_matches = re.findall(r'DRAM Uncorrectable\s+:\s+(\d+)', output)
    #     gpu_matches = re.findall(r'\nGPU\s+(.*)\n', output)
    #     vol_sram_line = sram_matches[0::2]
    #     vol_dram_line = dram_matches[0::2]
    #     agg_sram_line = sram_matches[1::2]
    #     agg_dram_line = dram_matches[1::2]

    #     for i, gpu in enumerate(gpu_matches):
    #         logger.debug(f"GPU: {gpu}")
    #         if vol_sram_line[i] != "0":
    #             logger.debug(f"Volatile SRAM Uncorrectable: {vol_sram_line[i]}")
    #             ecc_issues.append(f"{gpu_matches[i]} - Volatile SRAM Uncorrectable: {vol_sram_line[i]}")
    #         if vol_dram_line[i] != "0":
    #             logger.debug(f"Volatile DRAM Uncorrectable: {vol_dram_line[i]}")
    #             ecc_issues.append(f"{gpu_matches[i]} - Volatile DRAM Uncorrectable: {vol_dram_line[i]}")
    #         if agg_sram_line[i] != "0":
    #             logger.debug(f"Aggregate SRAM Uncorrectable: {agg_sram_line[i]}")
    #             ecc_issues.append(f"{gpu_matches[i]} - Aggregate SRAM Uncorrectable: {agg_sram_line[i]}")
    #         if agg_dram_line[i] != "0":
    #             logger.debug(f"Aggregate DRAM Uncorrectable: {agg_dram_line[i]}")
    #             ecc_issues.append(f"{gpu_matches[i]} - Aggregate DRAM Uncorrectable: {agg_dram_line[i]}")


    #     # Check if there are ecc_issues
    #     if len(ecc_issues) == 0:
    #         logger.info("GPU ECC Test: Passed")
    #     else:
    #         logger.warning("GPU ECC Test: Failed")

    #     return ecc_issues

    # def check_row_remap_errors():
    #     remap_issues = []
    #     try:
    #         # Run the nvidia-smi -q command
    #         result = subprocess.run(['nvidia-smi', '--query-remapped-rows=remapped_rows.pending,remapped_rows.failure,remapped_rows.uncorrectable', '--format=csv,noheader'], stdout=subprocess.PIPE)

    #         if result.returncode != 0:
    #             logger.debug(f"Check row remap command exited with error code: {result.returncode}")

    #     except FileNotFoundError:
    #         logger.warning("Skipping Row Remap Test: nvidia-smi command not found")
    #         return []

    #     # Decode the output from bytes to string
    #     output = result.stdout.decode('utf-8')
    #     logger.debug("Output: {}".format(output))
    #     for i, line in enumerate(output.split('\n')):
    #         if line == "":
    #             continue
    #         tmp_data = line.split(",")
    #         tmp_data = [x.strip() for x in tmp_data]
    #         if tmp_data[0] != "0":
    #             logger.debug(f"GPU: {i} - Row Remap Pending: {tmp_data[0]}")
    #             remap_issues.append(f"GPU: {i} Row Remap Pending: {tmp_data[0]}")
    #         if tmp_data[1] != "0":
    #             logger.debug(f"GPU: {i} - Row Remap Failure: {tmp_data[1]}")
    #             #remap_issues.append(f"GPU: {i} Row Remap Failure: {tmp_data[1]}")
    #         if tmp_data[2] != "0":
    #             logger.debug(f"GPU: {i} - Row Remap Uncorrectable: {tmp_data[2]}")
    #             if int(tmp_data[2]) > 512:
    #                 remap_issues.append(f"GPU: {i} - Row Remap Uncorrectable >512: {tmp_data[2]}")
    #             else:
    #                 remap_issues.append(f"GPU: {i} - Row Remap Uncorrectable <512: {tmp_data[2]}")# Check if there are ecc_issues

    #     if len(remap_issues) == 0:
    #         logger.info("GPU Remap Test: Passed")
    #     else:
    #         logger.warning("GPU Remap Test: Failed")

    #     return remap_issues

    def check_rdma_link_status():
        status = True
        metadata=get_metadata()
        shape=metadata['shape']
        if shape == "BM.GPU.H100.8":
            devices = ["mlx5_0", "mlx5_1", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        elif shape == "BM.GPU.B4.8" or shape == "BM.GPU.A100-v2.8":
            devices = ["mlx5_1", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        elif shape == "BM.GPU4.8":
            devices = ["mlx5_0", "mlx5_1", "mlx5_2", "mlx5_3", "mlx5_6", "mlx5_7", "mlx5_8", "mlx5_9", "mlx5_10", "mlx5_11", "mlx5_12", "mlx5_13", "mlx5_14", "mlx5_15", "mlx5_16", "mlx5_17"]
        elif shape == "BM.GPU.MI300X.8":
            devices = ["mlx5_0", "mlx5_2", "mlx5_3", "mlx5_4", "mlx5_5", "mlx5_7", "mlx5_8", "mlx5_9"]
        link_issues = []
        for device in devices:
            # Run the mlxlink command
            if not is_user_root():
                command = ['sudo', 'mlxlink', '-d', device, '-m', '-c', '-e']
            else:
                command = ['mlxlink', '-d', device, '-m', '-c', '-e']
            result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            # Decode the output from bytes to string
            output = result.stdout.decode('utf-8')
            stderr = result.stderr.decode('utf-8')

            if stderr and stderr.find("-E-") != -1:
                stderr = stderr.split("\n")
                stderr_line = ", ".join(stderr)
                logger.debug(f"{device}: {stderr_line}")
                link_issues.append(f"{device}: {stderr[0]}")
                status = "False"
                continue

            # Find the line containing "Recommendation"
            color_pattern = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
            link_state = re.search(r'\nState.*', output).group().split(":")[1].strip()
            recommendation = re.search(r'Recommendation.*', output).group().split(":")[1].strip()
            vendor_serial_num = re.search(r'Vendor Serial Number.*', output).group().split(":")[1].strip()
            nic_fw_version = re.search(r'Firmware Version.*', output).group().split(":")[1].strip()
            cable_fw_version = re.search(r'FW Version.*', output).group().split(":")[1].strip()
            physical_BER = re.search(r'Raw Physical BER.*', output).group().split(":")[1].strip()
            # Remove hidden characters from the output
            link_state = re.sub(color_pattern, '', link_state)
            nic_fw_version = re.sub(color_pattern, '', nic_fw_version)
            recommendation = re.sub(color_pattern, '', recommendation)

            logger.debug(f"{device}: {vendor_serial_num} - {cable_fw_version} - {nic_fw_version} - {link_state} - {recommendation}")

            # Extract the part after the ":" and print it along with the device name
            if link_state != "Active":
                logger.debug(f"{device}: {link_state}")
                link_issues.append(f"{device} - {vendor_serial_num} - {cable_fw_version} - {nic_fw_version}: {link_state}")
                status = False
            if not "No issue was observed" in recommendation:
                logger.debug(f"{device}: {recommendation}")
                if "Bad signal integrity" in recommendation and float(physical_BER) < 1e-07:
                    logger.debug(f"Recommandation is {recommendation} but the Physical error are low enough that it can be ignored")
                else : 
                    logger.debug(f"Recommandation is {recommendation} and the Physical error count is too high to be ignored: {physical_BER}")
                    link_issues.append(f"{device} - {vendor_serial_num} - {cable_fw_version} - {nic_fw_version}: {recommendation}")
                    status = False
            else:
                logger.debug(f"{device}: {recommendation}")

        if status:
            logger.info(f"RDMA Link Status Check: Passed")
        else:
            logger.warning(f"RDMA Link Status Check: Failed")
        return link_issues

    def get_host_serial():
        # Run the shell command
        if not is_user_root():
            result = subprocess.run(['sudo', 'dmidecode', '-s', 'system-serial-number'], stdout=subprocess.PIPE)
        else:
            result = subprocess.run(['dmidecode', '-s', 'system-serial-number'], stdout=subprocess.PIPE)

        # Decode the output from bytes to string
        output = result.stdout.decode('utf-8')

        # Return the serial number
        return output.strip()

    # def check_bus():
    #     # Check to see if any devices have fallen of the bus
    #     command = ['lspci', '-v']
    #     result = subprocess.run(command, stdout=subprocess.PIPE)
    #     output = result.stdout.decode('utf-8')
    #     lines = output.split('\n')
    #     bus_issues = []
    #     for line in lines:
    #         if line.find('(rev ff)') != -1:
    #             bus_issues.append(line)
    #     if len(bus_issues) > 0:
    #         logger.error(f"Devices have fallen off the bus")
    #     else:
    #         logger.info("No devices have fallen off the bus")
    #     if len(bus_issues) == 0:
    #         logger.info("Bus Check Test: Passed")
    #         return(bus_issues)
    #     else:
    #         logger.warning("Bus Check Test: Failed")
    #         return(bus_issues)

    # def check_gpu_count():

    #     lspci_expected_results = [  '0f:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
    #                                 '2d:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
    #                                 '44:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
    #                                 '5b:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
    #                                 '89:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
    #                                 'a8:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
    #                                 'c0:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)',
    #                                 'd8:00.0 3D controller: NVIDIA Corporation Device 2330 (rev a1)'
    #                              ]

    #     # Check the number of GPUs
    #     try:
    #         result = subprocess.run(['nvidia-smi', '--list-gpus'], stdout=subprocess.PIPE)
    #         output = result.stdout.decode('utf-8')
    #         lines = output.split('\n')
    #         tmp_results = []
    #         # remove empty lines
    #         lines = [line for line in lines if line]
    #         if len(lines) == 8:
    #             logger.info("GPU Count Test: Passed")
    #         else:
    #             logger.warning("GPU Count Test: Failed")
    #             tmp_results.append(f"Expected 8 GPUs, found {len(lines)} using nvidia-smi command")
    #         return tmp_results

    #     except FileNotFoundError:
    #         try:
    #             # Check if lspci is available
    #             result = subprocess.run(['lspci', '-v'], stdout=subprocess.PIPE)
    #             output = result.stdout.decode('utf-8')

    #             # Check if the expected results are in the output
    #             lines = output.split('\n')
    #             tmp_results = []
    #             missing_gpus = []
    #             for line in lines:
    #                 if line.find("NVIDIA") != -1 and line.find("2330") != -1:
    #                     tmp_results.append(line)
    #             if not len(tmp_results) == 8:
    #                 logger.debug(f"Expected 8 GPUs, found {len(tmp_results)} in lspci output")
    #                 for line in lspci_expected_results:
    #                     if line not in tmp_results:
    #                         missing_gpus.append(f"Missing GPU: {line}")
    #             if len(tmp_results) == 8:
    #                 logger.info("GPU Count Test: Passed")
    #             else:
    #                 logger.warning("GPU Count Test: Failed")
    #             return missing_gpus
    #         except FileNotFoundError:
    #             logger.warning("Skipping GPU count test: nvidia-smi and lspci commands not found")
    #             return None

    def slurm_reason(message):
        global slurm_drain_reason
        global slurm_error_count
        slurm_drain_reason+=(message+"\n")
        slurm_error_count+=1

    if __name__ == '__main__':
        parser = argparse.ArgumentParser(description='Check Host setup')
        parser.add_argument("-l", "--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"], default="INFO", help="Set the logging level default: INFO")
        parser.add_argument('--bw-test', dest='bw_test', action='store_true', default=False, help='Run GPU bandwidth test (default: False)')
        parser.add_argument('--bw-test-exe', dest='bw_test_exe', help='Location to cuda-sampels bandwidthTest')
        parser.add_argument('--lf-interval', dest='lf_interval', default=6, type=int, help='Link flapping interval with no flapping or link down events (default: 6 (hours))')
        parser.add_argument('-a','--all', dest='run_all', action='store_true', default=False, help='Run all checks (default: False)')
        parser.add_argument('-slurm','--slurm', dest='slurm', action='store_true', default=False, help='Add a Slurm message')
        args = parser.parse_args()

        logger.setLevel(args.log_level)

        datetime_str = datetime.now().strftime('%Y-%m-%d-%H%M%S')
        logger.info(f"Started GPU host setup check at: {datetime_str}")
        try:
            oca_version = get_oca_version()
        except Exception as e:
            logger.warning(f"Failed to get Oracle Cloud Agent version with error: {e}")
            oca_version = "Unknown"
        # try:
        #     rttcc_issues = check_rttcc_status()
        # except Exception as e:
        #     logger.warning(f"Failed to check RTTCC status with error: {e}")
        #     rttcc_issues = []

        # Check for ECC errors
        # try:
        #     ecc_issues = check_ecc_errors()
        # except Exception as e:
        #     logger.warning(f"Failed to check ECC errors with error: {e}")
        #     ecc_issues = []

        # # Check for row remap errors
        # try:
        #     remap_results = check_row_remap_errors()
        # except Exception as e:
        #     logger.warning(f"Failed to check row remap errors with error: {e}")
        #     remap_results = []

        # Check RDMA link status
        try:
            rdma_link_issues = check_rdma_link_status()
        except Exception as e:
            logger.warning(f"Failed to check RDMA link status with error: {e}")
            rdma_link_issues = []

        # Check for RDMA link flapping
        try:
            lft = LinkFlappingTest(time_interval=args.lf_interval)
            lft.get_rdma_link_failures()
            lft_issues = lft.process_rdma_link_flapping()
        except Exception as e:
            logger.warning(f"Failed to check RDMA link flapping with error: {e}")
            lft_issues = {"failures": [], "link_down": []}

        # # Check for GPU Xid errors
        # try:
        #     xc = XidChecker()
        #     xid_results = xc.check_gpu_xid()
        # except Exception as e:
        #     logger.warning(f"Failed to check GPU Xid errors with error: {e}")
        #     xid_results = {"status": "None", "results": {}}

        # # Check GPU bandwidth
        # bwt_results = None
        # try:
        #     if args.bw_test == True or args.run_all == True:
        #         if args.bw_test_exe:
        #             bwt = BandwidthTest(bw_test_exe=args.bw_test_exe)
        #         else:
        #             bwt = BandwidthTest()
        #         bwt.measure_gpu_bw()
        #         bwt_results = bwt.validate_results()
        # except Exception as e:
        #     logger.warning(f"Failed to check GPU bandwidth with error: {e}")
        #     bwt_results = None

        # Check the bus
        # try:
        #     bus_results = check_bus()
        # except Exception as e:
        #     logger.warning(f"Failed to check the bus with error: {e}")
        #     bus_results = None

        # # Check the number of GPUs
        # try:
        #     gpu_results = check_gpu_count()
        # except Exception as e:
        #     logger.warning(f"Failed to check the number of GPUs with error: {e}")
        #     gpu_results = None

        # Summarize the results
        try:
            host_serial = get_host_serial()
        except Exception as e:
            logger.warning(f"Failed to get host serial number with error: {e}")
            host_serial = "Unknown"

        slurm_drain_reason = ""
        slurm_error_count = 0

        logger.info(f"--------- Summary of Host setup check for {host_serial} ---------")
        if oca_version < "1.39.0":
            logger.error(f"Oracle Cloud Agent: {oca_version} needs to be updated to 1.39.0 or higher")
            slurm_reason("OCA version Error")
        # if len(rttcc_issues) > 0:
        #     logger.error(f"RTTCC issues: {rttcc_issues}")
        #     slurm_reason("RTTCC Error")
        # if len(ecc_issues) > 0:
        #     ecc_error=False
        #     for issue in ecc_issues:
        #         if "Skipped" in issue:
        #             logger.warning(f"{host_serial} - {issue}")
        #         else:
        #             if "Aggregate" in issue:
        #                 logger.warning(f"{host_serial} - ECC issues: {issue}")
        #             else:
        #                 logger.error(f"{host_serial} - ECC issues: {issue}")
        #                 ecc_error=True
        #     if ecc_error:
        #         slurm_reason("ECC Error")
        # if len(remap_results) > 0:
        #     remap_error=False
        #     for issue in remap_results:
        #         if "<512" in issue:
        #             logger.warning(f"{host_serial} - {issue}")
        #         else:
        #             logger.error(f"{host_serial} - {issue}")
        #             remap_error=True
        #     if remap_error:
        #         slurm_reason("Remap Error")
        # if xid_results["status"] == "Failed":
        #     for xid in xid_results["results"]:
        #         for pci in xid_results["results"][xid]["results"]:
        #             logger.error(f"{host_serial} - GPU Xid {xid} device: {pci}, {xid_results['results'][xid]['description']}")
        #             slurm_reason("XID Error")
        if len(rdma_link_issues) > 0:
            for issue in rdma_link_issues:
                logger.error(f"{host_serial} - RDMA link issues: {issue}")
                slurm_reason("RDMA Link Error")
        if len(lft_issues["failures"]) > 0 or len(lft_issues["link_down"]) > 0:
            if len(lft_issues["failures"]) > 0:
                for issue in lft_issues["failures"]:
                    logger.error(f"{host_serial} - RDMA link flapping issues: {issue}")
                    slurm_reason("RDMA Link Flapping Error")
            if len(lft_issues["link_down"]) > 0:
                for issue in lft_issues["link_down"]:
                    logger.error(f"{host_serial} - RDMA link down issues: {issue}")
                    slurm_reason("RDMA Link Down Error")
        # if bwt_results != None:
        #     if bwt_results["status"] == "Failed":
        #         for issue in bwt_results["issues"]:
        #             logger.error(f"{host_serial} - GPU bandwidth issues: {issue}")
        #             slurm_reason("GPU Bwt Error")
        # if bus_results:
        #     logger.error(f"{host_serial} - Bus issues: {bus_results}")
        #     slurm_reason("GPU Bus Error")
        # if gpu_results:
        #     logger.error(f"{host_serial} - Missing GPU(s): {gpu_results}")
        #     slurm_reason("Missing GPU Error")

        datetime_str = datetime.now().strftime('%Y-%m-%d-%H%M%S')
        logger.info(f"Finished GPU host setup check at: {datetime_str}")

        if slurm_error_count > 0 and args.slurm:
            print("Healthcheck:: "+slurm_drain_reason[:-1])

  rdma_link_flapping.py: |
        #!/usr/bin/env python3

        import os
        import sys
        import time
        import datetime
        import re
        import argparse
        import socket
        import subprocess
        from shared_logging import logger


        class LinkFlappingTest:
            def __init__(self, time_interval=6):
                self.results = None
                self.time_interval = int(time_interval)
                self.link_data = None

                # Check if the log file exists
                msg_file = "/var/log/messages"
                if not os.path.exists(msg_file):
                    msg_file = "/var/log/syslog"
                self.log_file = msg_file

            def get_rdma_link_failures(self):

                pattern  = r"(\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+\S+\s+wpa_supplicant(?:\[\d+\])?: (\w+): CTRL-EVENT-EAP-FAILURE EAP authentication failed"
                pattern2 = r"(\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+\S+\s+kernel: (?:\[\d+\.\d+\]\s)?mlx5_core \S+ (\w+): Link down"
                
                self.link_data = {}
                with open(self.log_file, "r") as f:
                    for line in f:
                        match = re.search(pattern, line)
                        if match:
                            time_str = match.group(1)
                            interface = match.group(2)
                            logger.debug(f"time: {time_str}, interface: {interface}")
                            if interface not in self.link_data:
                                self.link_data[interface] = {"failures": [time_str], "link_down": []}
                            else:
                                self.link_data[interface]["failures"].append(time_str)

                        
                        match = re.search(pattern2, line)
                        if match:
                            time_str = match.group(1)
                            interface = match.group(2)
                            logger.debug(f"time: {time_str}, interface: {interface}")
                            if interface not in self.link_data:
                                self.link_data[interface] = {"failures": [], "link_down": [time_str]}
                            else:
                                self.link_data[interface]["link_down"].append(time_str)
                                
                logger.debug("Link Data: {}".format(self.link_data))
                return self.link_data

            def process_rdma_link_flapping(self):

                link_issues = {"failures": [], "link_down": []}

                # Get the time stamp when the host came up
                bootup_time = subprocess.run(['uptime', '-s'], stdout=subprocess.PIPE)
                bootup_time = bootup_time.stdout.decode('utf-8').strip()
                bootup_time_str = datetime.datetime.strptime(bootup_time, "%Y-%m-%d %H:%M:%S")
                bootup_time_sec = int(time.mktime(bootup_time_str.timetuple()))
                bootup_time_grace_period = bootup_time_sec + 1800

                status = 0
                if len(self.link_data) >= 0:
                    current_date = datetime.datetime.now()
                    current_date_str = current_date.strftime("%Y-%b-%d %H:%M:%S")
                    current_date_sec = int(time.mktime(datetime.datetime.strptime(current_date_str, "%Y-%b-%d %H:%M:%S").timetuple()))
                    
                    link_failures = False
                    for interface in self.link_data:
                        if len(self.link_data[interface]["failures"]) > 0:
                            link_failures = True
                            logger.debug(f"{interface}: {len(self.link_data[interface]['failures'])} RDMA link failure entries in {self.log_file}")
                            logger.debug(f"{interface}: {self.link_data[interface]['failures']}")        
                        last_date_failure_str = None

                        if len(self.link_data[interface]["failures"]) > 0:
                            last_date_failure_str = self.link_data[interface]["failures"][-1]
                            last_date_failure = datetime.datetime.strptime(last_date_failure_str, "%b %d %H:%M:%S")

                            # Compare the month of the last failure date with the current month
                            if last_date_failure.month > current_date.month:
                                # If the last failure month is greater than the current month, subtract one from the current year
                                last_date_failure = last_date_failure.replace(year=current_date.year - 1)
                            else:
                                # Otherwise, set the year of the last failure date to the current year
                                last_date_failure = last_date_failure.replace(year=current_date.year)

                            # Convert the last failure date to seconds since the epoch
                            last_date_failure_sec = int(time.mktime(last_date_failure.timetuple()))
                        
                        if last_date_failure_str != None and last_date_failure_str != current_date_str:
                            diff_secs = current_date_sec - last_date_failure_sec
                            diff_hours = diff_secs // (60 * 60)
                            logger.debug(f"RDMA link ({interface}) failed  {diff_hours} hours ago")

                            logger.debug(f"bootup_time_sec: {bootup_time_sec}, boot_time_grace_period: {bootup_time_grace_period}, current_date_sec: {current_date_sec}, diff_secs: {diff_secs}, diff_hours: {diff_hours}")
                            if diff_hours < self.time_interval and last_date_failure_sec > bootup_time_grace_period:
                                logger.debug(f"{interface}: one or more RDMA link flapping events within {self.time_interval} hours. Last flapping event: {last_date_failure_str})")
                                link_issues["failures"].append(f"{interface}: {len(self.link_data[interface]['failures'])}")
                                status = -1

                    for interface in self.link_data:
                        if len(self.link_data[interface]["link_down"]) > 0:
                            logger.debug(f"{interface}: {len(self.link_data[interface]['link_down'])} RDMA link down entries in {self.log_file}")
                            logger.debug(f"{interface}: {self.link_data[interface]['link_down']}")
                        last_date_down_str = None

                        if len(self.link_data[interface]["link_down"]) > 0:
                                last_date_down_str = self.link_data[interface]["link_down"][-1]
                                last_date_down = datetime.datetime.strptime(last_date_down_str, "%b %d %H:%M:%S")

                                # Compare the month of the last failure date with the current month
                                if last_date_down.month > current_date.month:
                                    # If the last failure month is greater than the current month, subtract one from the current year
                                    last_date_down = last_date_down.replace(year=current_date.year - 1)
                                else:
                                    # Otherwise, set the year of the last failure date to the current year
                                    last_date_down = last_date_down.replace(year=current_date.year)

                                # Convert the last failure date to seconds since the epoch
                                last_date_down_sec = int(time.mktime(last_date_down.timetuple()))


                        if last_date_down_str != None and last_date_down_str != current_date_str:
                            diff_secs = current_date_sec - last_date_down_sec
                            diff_hours = diff_secs // (60 * 60)
                            logger.debug(f"RDMA link ({interface}) down  {diff_hours} hours ago")
                            
                            logger.debug(f"bootup_time_sec: {bootup_time_sec}, boot_time_grace_period: {bootup_time_grace_period}, current_date_sec: {current_date_sec}, diff_secs: {diff_secs}, diff_hours: {diff_hours}")
                            if diff_hours < self.time_interval and last_date_down_sec > bootup_time_grace_period:
                                logger.debug(f"{interface}, one or more RDMA link down events within {self.time_interval} hours. Last link down event: {last_date_down_str}")
                                link_issues["link_down"].append(f"{interface}: {len(self.link_data[interface]['link_down'])}")
                                status = -2
                    if status == -1:
                        logger.debug(f"One or more RDMA link flapping events within the past {self.time_interval} hours")
                    if status == -2:
                        logger.debug(f"One or more RDMA link down events within the past {self.time_interval} hours")

                else:
                    logger.info("No RDMA link failures entry in /var/log/messages")
                if status == 0:    
                    logger.info("RDMA link flapping/down test: Passed")
                else:
                    logger.warning("RDMA link flapping/down test: Failed")
                return link_issues


        if __name__ == "__main__":

            parser = argparse.ArgumentParser(description="Process RDMA link flapping data")
            parser.add_argument("-l", "--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"], default="INFO", help="Set the logging level")
            args = parser.parse_args()

            logger.setLevel(args.log_level)

            auth_failure_file = "/tmp/last_auth_failure_date"
            msg_file = "/var/log/messages"
            if not os.path.exists(msg_file):
                msg_file = "/var/log/syslog"
            time_interval_hours = 6
            lft = LinkFlappingTest(time_interval=time_interval_hours)
            link_data = lft.get_rdma_link_failures()
            lft.process_rdma_link_flapping()
  xid_checker.py: |
    #!/usr/bin/env python3

    import argparse
    from shared_logging import logger
    import subprocess
    import sys
    import re
    import os

    class XidChecker:
        def __init__(self, dmesg_cmd="dmesg", time_interval=60):
            # if user is root
            if not os.geteuid() == 0:
                logger.info("The XidChecker script did not run since it must be run as root")
                sys.exit(1)
            self.dmesg_cmd = dmesg_cmd
            self.results = {}


            # Check for the following GPU Xid errors in dmesg
            self.XID_EC = {
                    "1": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                    "2": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                    "3": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                    "4": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                    "5": {"description": "Unused", "severity": "Critical"},
                    "6": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                    "7": {"description": "Invalid or corrupted push buffer address", "severity": "Critical"},
                    "8": {"description": "GPU stopped processing", "severity": "Critical"},
                    "9": {"description": "Driver error programming GPU", "severity": "Critical"},
                    "10": {"description": "Unused", "severity": "Critical"},
                    "11": {"description": "Invalid or corrupted push buffer stream", "severity": "Critical"},
                    "12": {"description": "Driver error handling GPU exception", "severity": "Critical"},
                    "13": {"description": "Graphics Engine Exception", "severity": "Critical"},
                    "14": {"description": "Unused", "severity": "Warn"},
                    "15": {"description": "Unused", "severity": "Warn"},
                    "16": {"description": "Display engine hung", "severity": "Warn"},
                    "17": {"description": "Unused", "severity": "Warn"},
                    "18": {"description": "Bus mastering disabled in PCI Config Space", "severity": "Warn"},
                    "19": {"description": "Display Engine error", "severity": "Warn"},
                    "20": {"description": "Invalid or corrupted Mpeg push buffer", "severity": "Warn"},
                    "21": {"description": "Invalid or corrupted Motion Estimation push buffer", "severity": "Warn"},
                    "22": {"description": "Invalid or corrupted Video Processor push buffer", "severity": "Warn"},
                    "23": {"description": "Unused", "severity": "Warn"},
                    "24": {"description": "GPU semaphore timeout", "severity": "Warn"},
                    "25": {"description": "Invalid or illegal push buffer stream", "severity": "Warn"},
                    "26": {"description": "Framebuffer timeout", "severity": "Warn"},
                    "27": {"description": "Video processor exception", "severity": "Warn"},
                    "28": {"description": "Video processor exception", "severity": "Warn"},
                    "29": {"description": "Video processor exception", "severity": "Warn"},
                    "30": {"description": "GPU semaphore access error", "severity": "Warn"},
                    "31": {"description": "GPU memory page fault", "severity": "Critical"},    
                    "32": {"description": "Invalid or corrupted push buffer stream", "severity": "Warn"},
                    "33": {"description": "Internal micro-controller error", "severity": "Warn"},
                    "34": {"description": "Video processor exception", "severity": "Warn"},
                    "35": {"description": "Video processor exception", "severity": "Warn"},
                    "36": {"description": "Video processor exception", "severity": "Warn"},
                    "37": {"description": "Driver firmware error", "severity": "Warn"},
                    "38": {"description": "Driver firmware error", "severity": "Warn"},
                    "39": {"description": "Unused", "severity": "Warn"},
                    "40": {"description": "Unused", "severity": "Warn"},
                    "41": {"description": "Unused", "severity": "Warn"},
                    "42": {"description": "Video processor exception", "severity": "Warn"},
                    "43": {"description": "GPU stopped processing", "severity": "Warn"},
                    "44": {"description": "Graphics Engine fault during context switch", "severity": "Warn"},
                    "45": {"description": "Preemptive cleanup, due to previous errors -- Most likely to see when running multiple cuda applications and hitting a DBE", "severity": "Warn"},
                    "46": {"description": "GPU stopped processing", "severity": "Warn"},
                    "47": {"description": "Video processor exception", "severity": "Warn"},
                    "48": {"description": "Double Bit ECC Error", "severity": "Critical"}, 
                    "49": {"description": "Unused", "severity": "Warn"},
                    "50": {"description": "Unused", "severity": "Warn"},
                    "51": {"description": "Unused", "severity": "Warn"},
                    "52": {"description": "Unused", "severity": "Warn"},
                    "53": {"description": "Unused", "severity": "Warn"},
                    "54": {"description": "Auxiliary power is not connected to the GPU board", "severity": "Warn"},
                    "55": {"description": "Unused", "severity": "Warn"},
                    "56": {"description": "Display Engine error", "severity": "Critical"},
                    "57": {"description": "Error programming video memory interface", "severity": "Critical"},
                    "58": {"description": "Unstable video memory interface detected", "severity": "Critical"},
                    "59": {"description": "Internal micro-controller error (older drivers)", "severity": "Warn"},
                    "60": {"description": "Video processor exception", "severity": "Warn"},
                    "61": {"description": "Internal micro-controller breakpoint/warning (newer drivers)", "severity": "Warn"},
                    "62": {"description": "Internal micro-controller halt", "severity": "Critical"},
                    "63": {"description": "ECC page retirement or row remapping recording event", "severity": "Critical"},
                    "64": {"description": "ECC page retirement or row remapper recording failure", "severity": "Critical"},
                    "65": {"description": "Video processor exception", "severity": "Critical"},
                    "66": {"description": "Illegal access by driver", "severity": "Warn"},
                    "67": {"description": "Illegal access by driver", "severity": "Warn"},
                    "68": {"description": "NVDEC0 Exception", "severity": "Critical"},
                    "69": {"description": "Graphics Engine class error", "severity": "Critical"},
                    "70": {"description": "CE3: Unknown Error", "severity": "Warn"},
                    "71": {"description": "CE4: Unknown Error", "severity": "Warn"},
                    "72": {"description": "CE5: Unknown Error", "severity": "Warn"},
                    "73": {"description": "NVENC2 Error", "severity": "Critical"},
                    "74": {"description": "NVLINK Error", "severity": "Critical"},
                    "75": {"description": "CE6: Unknown Error", "severity": "Warn"},
                    "76": {"description": "CE7: Unknown Error", "severity": "Warn"},
                    "77": {"description": "CE8: Unknown Error", "severity": "Warn"},
                    "78": {"description": "vGPU Start Error", "severity": "Warn"},
                    "79": {"description": "GPU has fallen off the bus", "severity": "Critical"},
                    "80": {"description": "Corrupted data sent to GPU", "severity": "Critical"},
                    "81": {"description": "VGA Subsystem Error", "severity": "Critical"},
                    "82": {"description": "NVJPGO Error", "severity": "Warn"},
                    "83": {"description": "NVDEC1 Error", "severity": "Warn"},
                    "84": {"description": "NVDEC2 Error", "severity": "Warn"},
                    "85": {"description": "CE9: Unknown Error", "severity": "Warn"},
                    "86": {"description": "OFA Exception", "severity": "Warn"},
                    "87": {"description": "Reserved", "severity": "Warn"},
                    "88": {"description": "NVDEC3 Error", "severity": "Warn"},
                    "89": {"description": "NVDEC4 Error", "severity": "Warn"},
                    "90": {"description": "Reserved", "severity": "Warn"},
                    "91": {"description": "Reserved", "severity": "Warn"},
                    "92": {"description": "High single-bit ECC error rate", "severity": "Critical"},
                    "93": {"description": "Non-fatal violation of provisioned InfoROM wear limit", "severity": "Warn"},
                    "94": {"description": "Contained ECC error", "severity": "Critical"},
                    "95": {"description": "Uncontained ECC error", "severity": "Critical"},
                    "96": {"description": "NVDEC5 Error", "severity": "Warn"},
                    "97": {"description": "NVDEC6 Error", "severity": "Warn"},
                    "98": {"description": "NVDEC7 Error", "severity": "Warn"},
                    "99": {"description": "NVJPG1 Error", "severity": "Warn"},
                    "100": {"description": "NVJPG2 Error", "severity": "Warn"},
                    "101": {"description": "NVJPG3 Error", "severity": "Warn"},
                    "102": {"description": "NVJPG4 Error", "severity": "Warn"},
                    "103": {"description": "NVJPG5 Error", "severity": "Warn"},
                    "104": {"description": "NVJPG6 Error", "severity": "Warn"},
                    "105": {"description": "NVJPG7 Error", "severity": "Warn"},
                    "106": {"description": "SMBPBI Test Message", "severity": "Warn"},
                    "107": {"description": "SMBPBI Test Message Silent", "severity": "Warn"},
                    "108": {"description": "Reserved", "severity": "Warn"},
                    "109": {"description": "Context Switch Timeout Error", "severity": "Critical"},
                    "110": {"description": "Security Fault Error", "severity": "Warn"},
                    "111": {"description": "Display Bundle Error Event", "severity": "Warn"},
                    "112": {"description": "Display Supervisor Error", "severity": "Warn"},
                    "113": {"description": "DP Link Training Error", "severity": "Warn"},
                    "114": {"description": "Display Pipeline Underflow Error", "severity": "Warn"},
                    "115": {"description": "Display Core Channel Error", "severity": "Warn"},
                    "116": {"description": "Display Window Channel Error", "severity": "Warn"},
                    "117": {"description": "Display Cursor Channel Error", "severity": "Warn"},
                    "118": {"description": "Display Pixel Pipeline Error", "severity": "Warn"},
                    "119": {"description": "GSP RPC Timeout", "severity": "Critical"},
                    "120": {"description": "GSP Error", "severity": "Critical"},
                    "121": {"description": "C2C Link Error", "severity": "Critical"},
                    "122": {"description": "SPI PMU RPC Read Failure", "severity": "Warn"},
                    "123": {"description": "SPI PMU RPC Write Failure", "severity": "Warn"},
                    "124": {"description": "SPI PMU RPC Erase Failure", "severity": "Warn"},
                    "125": {"description": "Inforom FS Failure", "severity": "Warn"},
                    "126": {"description": "Reserved", "severity": "Warn"},
                    "127": {"description": "Reserved", "severity": "Warn"},
                    "128": {"description": "Reserved", "severity": "Warn"},
                    "129": {"description": "Reserved", "severity": "Warn"},
                    "130": {"description": "Reserved", "severity": "Warn"},
                    "131": {"description": "Reserved", "severity": "Warn"},
                    "132": {"description": "Reserved", "severity": "Warn"},
                    "133": {"description": "Reserved", "severity": "Warn"},
                    "134": {"description": "Reserved", "severity": "Warn"},
                    "135": {"description": "Reserved", "severity": "Warn"},
                    "136": {"description": "Reserved", "severity": "Warn"},
                    "137": {"description": "Reserved", "severity": "Warn"},
                    "138": {"description": "Reserved", "severity": "Warn"},
                    "139": {"description": "Reserved", "severity": "Warn"},
                    "140": {"description": "Unrecovered ECC Error", "severity": "Warn"},
                    "141": {"description": "Reserved", "severity": "Warn"},
                    "142": {"description": "Reserved", "severity": "Warn"},
                    "143": {"description": "GPU Initialization Failure", "severity": "Warn"}
                    }

        def check_gpu_xid(self):
            status = "Pass"
            dmesg_output = subprocess.check_output([self.dmesg_cmd]).decode("utf-8")
            if "NVRM: Xid" in dmesg_output:
                for XID in self.XID_EC.keys():
                    logger.debug(f"Checking for GPU Xid {XID} error in dmesg")
                    
                    matches = re.findall(f"NVRM: Xid \(PCI:(.*?): {XID},", dmesg_output)
                    tmp_dict = {}
                    for match in matches:
                        if match not in tmp_dict:
                            tmp_dict[match] = 1
                        else:
                            tmp_dict[match] = tmp_dict[match] + 1
                    for x in tmp_dict.keys():
                        logger.info(f"{XID} : count: {tmp_dict[x]}, {self.XID_EC[XID]['description']} - PCI: {x}")
                    if not matches:
                        logger.debug(f"No GPU Xid {XID} error found in dmesg")
                    if tmp_dict != {}:
                        if self.XID_EC[XID]['severity'] == "Critical":
                            status = "Failed"
                        self.results[XID] = {"results": tmp_dict, "description": self.XID_EC[XID]['description']}
            else:
                logger.info("Xid Check: Passed")
            return {"status": status, "results": self.results}


    if __name__ == '__main__':
        # Argument parsing
        parser = argparse.ArgumentParser(description='Check for GPU Xid errors.')
        parser.add_argument('--dmesg_cmd', default='dmesg', help='Dmesg file to check. Default is dmesg.')
        args = parser.parse_args()


        logger.debug(f"Using dmesg command: {args.dmesg_cmd}")
        
        xc = XidChecker(dmesg_cmd=args.dmesg_cmd)
        results = xc.check_gpu_xid()
        logger.debug("Status: {}, Results: {}".format(results["status"], results["results"]))

  shared_logging.py: |
    #!/usr/bin/env python3

    import logging
    logging.basicConfig(level="INFO", format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger('nhc')

  oke-healthchecks.sh: |
    #!/bin/sh

    readonly OK=0
    readonly NONOK=1
    readonly UNKNOWN=2

    shape=$(chroot /host bash -c 'curl -sH "Authorization: Bearer Oracle" -L http://169.254.169.254/opc/v2/instance/shape')
    cp ./config/plugin/*.py /host/tmp

    if [ "${shape}" = "BM.GPU.H100.8" ] || [ "${shape}" = "BM.GPU.A100-v2.8" ] || [ "${shape}" = "BM.GPU4.8" ] || [ "${shape}" = "BM.GPU.B4.8" ]
    then
        chroot /host bash -c "/tmp/check_nvidia_gpu_setup.py --slurm > /tmp/latest_healthcheck.log 2>&1"
    elif [ "${shape}" = "BM.GPU.MI300X.8" ]
    then
        chroot /host bash -c "/tmp/check_amd_gpu_setup.py --slurm > /tmp/latest_healthcheck.log 2>&1"
    fi

    ERROR_MSG=$(cat /host/tmp/latest_healthcheck.log | grep "Healthcheck::")

    if [ "$ERROR_MSG" != "" ]
    then
    echo "${ERROR_MSG#* }"
    exit $NONOK
    else
    echo "No errors found"
    exit $OK
    fi
kind: ConfigMap
metadata:
  name: oke-gpu-rdma-npd-config
  namespace: kube-system
